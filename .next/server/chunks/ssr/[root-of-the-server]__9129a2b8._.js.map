{"version":3,"sources":["../../../../node_modules/next/src/server/route-modules/app-page/vendored/contexts/app-router-context.ts","../../../../node_modules/next/src/server/route-modules/app-page/vendored/contexts/hooks-client-context.ts","../../../../node_modules/next/src/server/route-modules/app-page/vendored/contexts/server-inserted-html.ts","../../../../node_modules/next/src/server/route-modules/app-page/module.compiled.js","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.ts","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts","../../../../src/lib/api/client.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['contexts'].AppRouterContext\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['contexts'].HooksClientContext\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['contexts'].ServerInsertedHtml\n","if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxRuntime\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n","import type { ApiResponse, ApiErrorResponse } from '@/types/api';\n\n// ============================================\n// API Client — fetch-based, no extra deps\n// ============================================\n\nconst API_BASE_URL =\n    process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080/api/v1';\n\n/**\n * Custom error class for API errors\n */\nexport class ApiError extends Error {\n    code: string;\n    status: number;\n    details?: Record<string, string>;\n\n    constructor(status: number, code: string, message: string, details?: Record<string, string>) {\n        super(message);\n        this.name = 'ApiError';\n        this.status = status;\n        this.code = code;\n        this.details = details;\n    }\n}\n\n/**\n * In-memory token store (more secure than localStorage)\n */\nlet accessToken: string | null = null;\n\nexport function setAccessToken(token: string | null) {\n    accessToken = token;\n}\n\nexport function getAccessToken(): string | null {\n    return accessToken;\n}\n\n/**\n * Flag to prevent multiple simultaneous refresh attempts\n */\nlet isRefreshing = false;\nlet refreshPromise: Promise<string | null> | null = null;\n\n/**\n * Attempt to refresh the access token using the HttpOnly refresh cookie\n */\nasync function refreshAccessToken(): Promise<string | null> {\n    // If already refreshing, wait for the existing promise\n    if (isRefreshing && refreshPromise) {\n        return refreshPromise;\n    }\n\n    isRefreshing = true;\n    refreshPromise = (async () => {\n        try {\n            const response = await fetch(`${API_BASE_URL}/admin/auth/refresh`, {\n                method: 'POST',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n            });\n\n            if (!response.ok) {\n                setAccessToken(null);\n                return null;\n            }\n\n            const data: ApiResponse<{ accessToken: string }> = await response.json();\n            const newToken = data.data.accessToken;\n            setAccessToken(newToken);\n            return newToken;\n        } catch {\n            setAccessToken(null);\n            return null;\n        } finally {\n            isRefreshing = false;\n            refreshPromise = null;\n        }\n    })();\n\n    return refreshPromise;\n}\n\n/**\n * Core fetch wrapper with auth, error handling, and auto-refresh\n */\nasync function request<T>(\n    endpoint: string,\n    options: RequestInit = {},\n    retry = true\n): Promise<T> {\n    const headers: Record<string, string> = {\n        'Content-Type': 'application/json',\n        ...(options.headers as Record<string, string>),\n    };\n\n    // Attach access token if available\n    const token = getAccessToken();\n    if (token) {\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    console.log(`[API Request] ${options.method || 'GET'} ${endpoint}`);\n\n    const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n        ...options,\n        headers,\n        credentials: 'include', // Send HttpOnly refresh token cookie\n    });\n\n    console.log(`[API Response] ${options.method || 'GET'} ${endpoint} -> ${response.status}`);\n\n    // Handle 401 — try refreshing the token once\n    if (response.status === 401 && retry) {\n        const newToken = await refreshAccessToken();\n        if (newToken) {\n            // Retry the original request with the new token\n            return request<T>(endpoint, options, false);\n        }\n        // Refresh failed — clear state, redirect will be handled by AuthContext\n        setAccessToken(null);\n    }\n\n    // Parse response body\n    const body = await response.json().catch(() => null);\n\n    if (!response.ok) {\n        const errorBody = body as ApiErrorResponse | null;\n        throw new ApiError(\n            response.status,\n            errorBody?.error?.code || 'UNKNOWN_ERROR',\n            errorBody?.error?.message || 'An unexpected error occurred',\n            errorBody?.error?.details\n        );\n    }\n\n    return body as T;\n}\n\n// ============================================\n// Typed HTTP methods\n// ============================================\n\nexport function get<T>(endpoint: string): Promise<T> {\n    return request<T>(endpoint, { method: 'GET' });\n}\n\nexport function post<T>(endpoint: string, data?: unknown): Promise<T> {\n    return request<T>(endpoint, {\n        method: 'POST',\n        body: data ? JSON.stringify(data) : undefined,\n    });\n}\n\nexport function put<T>(endpoint: string, data?: unknown): Promise<T> {\n    return request<T>(endpoint, {\n        method: 'PUT',\n        body: data ? JSON.stringify(data) : undefined,\n    });\n}\n\nexport function del<T>(endpoint: string): Promise<T> {\n    return request<T>(endpoint, { method: 'DELETE' });\n}\n"],"names":["module","exports","require","vendored","AppRouterContext","HooksClientContext","ServerInsertedHtml","process","env","NEXT_RUNTIME","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK","ReactJsxRuntime","React"],"mappings":"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","ignoreList":[0,1,2,3,4,5]}